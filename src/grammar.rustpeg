use super::Rounding;

number -> i32
	= n:$([0-9]+) { n.parse().unwrap() }

decimal -> f32
    = n:$([0-9.]+) { n.parse().unwrap() }

signed_decimal -> f32
    = n:$(("+" / "-")? [0-9.]+) { n.parse().unwrap() }

units -> i32
    = u:$("D"i / "H"i / "M"i / "S"i) {
        let u: &str = &u.to_uppercase();
        match u {
            "D" => 86400,
            "H" => 3600,
            "M" => 60,
            "S" => 1,
            _ => 0
        }
    }

up -> Rounding
    = ("+" / "U"i)? i:decimal j:units? {
        Rounding::Up(i * j.unwrap_or(60) as f32)
    }

down -> Rounding
    = ("-" / "D"i) i:decimal j:units? {
        Rounding::Down(i * j.unwrap_or(60) as f32)
    }

half -> Rounding
    = ("=" / "H"i / "E"i) i:decimal j:units? {
        Rounding::Half(i * j.unwrap_or(60) as f32)
    }

pub rounding -> Rounding
    = up / down / half


//date & time offsets

offset_units -> f32
    = n:signed_decimal m:units { n * m as f32 }

offset_hh -> i32
    = n:$(("+" / "-")? [0-9]*<1,2>) { n.parse().unwrap() }

offset_mm -> i32
    = n:$([0-9]*<2>) { n.parse().unwrap() }

offset_hhmm -> f32
    = h:offset_hh ":" m:offset_mm {
        if h.is_negative() {
            ((h * 3600) + (-m * 60)) as f32
        } else {
            ((h * 3600) + (m * 60)) as f32
        }
}

pub offset -> f32
    = offset_units / offset_hhmm
