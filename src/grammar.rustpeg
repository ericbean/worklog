use super::Rounding;

number -> i32
	= n:$([0-9]+) { n.parse().unwrap() }

decimal -> f32
    = n:$([0-9.]+) { n.parse().unwrap() }

signed_decimal -> f32
    = n:$(("+" / "-")? [0-9.]+) { n.parse().unwrap() }

units -> i32
    = u:$("D"i / "H"i / "M"i / "S"i) {
        match u.to_uppercase().as_ref() {
            "D" => 86400,
            "H" => 3600,
            "M" => 60,
            "S" => 1,
            _ => 0
        }
    }

pub rounding -> Rounding
    = d:$("+" / "U"i / "-" / "D"i / "=" / "H"i / "E"i)? i:decimal j:units? {
        let seconds = i * j.unwrap_or(60) as f32;
        match d.to_uppercase().as_ref() {
            "+" | "U" => Rounding::Up(seconds),
            "-" | "D" => Rounding::Down(seconds),
            "=" | "H" => Rounding::Half(seconds),
            _ => Rounding::Up(seconds),
        }
    } 


//date & time offsets

offset_units -> f32
    = n:signed_decimal m:units { n * m as f32 }

offset_hh -> i32
    = n:$(("+" / "-")? [0-9]*<1,2>) { n.parse().unwrap() }

offset_mm -> i32
    = n:$([0-9]*<2>) { n.parse().unwrap() }

offset_hhmm -> f32
    = h:offset_hh ":" m:offset_mm {
        if h.is_negative() {
            ((h * 3600) + (-m * 60)) as f32
        } else {
            ((h * 3600) + (m * 60)) as f32
        }
}

pub offset -> f32
    = offset_units / offset_hhmm


// time formats

hour -> u32
    = n:$([0-9]*<1,2>) { n.parse().unwrap() }

minute -> u32
    = n:$([0-9]*<2>) { n.parse().unwrap() }

second -> f32
    = n:$([0-9.]*<1,12>) { n.parse().unwrap() }

meridiem -> u32
    = a:$("AM"i / "PM"i) {
        match a.to_uppercase().as_ref() {
            "AM" => 0,
            "PM" => 12,
            _ => 0
        }
    }

pub time -> (u32, u32, f32)
    = h:hour ":" m:minute ":"? s:second? " "? mer:meridiem? {
        let h = h + mer.unwrap_or(0);
        let s = s.unwrap_or(0.0);
        (h,m,s)
    }
